module Main where

-- Haskell module generated by the BNF converter

import Text.PrettyPrint
import Text.PrettyPrint.GenericPretty
import LexAssignment
import ParAssignment
import ErrM
import System.Environment
import AbsAssignment
import SkelAssignment
import AST

instance (Out a) => Out (M_prog a) where
  doc (M_prog (a, b)) = parens $ text "M_prog" $$ nest 2 (docList a) 
                                                    $$ nest 2 (docList b) 
  docPrec _ = doc
  
instance (Out a) => Out (M_decl a) where
  doc (M_var (a, b, c)) = parens $ text "M_var" <+> (doc a)
                                                    <+> (doc b)
                                                    <+> (doc c) 

  doc (M_fun (a, b, c, d, e)) = parens $ text "M_fun" $$ nest 2 (doc a)
                                                    $$ nest 2 (doc b)
                                                    $$ nest 2 (doc c)
                                                    $$ nest 2 (doc d)
                                                    $$ nest 2 (doc e)
  docPrec _ = doc
  
instance (Out a) => Out (M_stmt a) where
  doc (M_ass (a, b, c))  = parens $ text "M_ass" $$ nest 2 (doc a)
                                                    $$ nest 2 (doc b)
                                                    $$ nest 2 (doc c)
  doc (M_while (a, b))   = parens $ text "M_while" $$ nest 2 (doc a)
                                                    $$ nest 2 (doc b)
  doc (M_cond (a, b, c)) = parens $ text "M_cond" $$ nest 2 (doc a)
                                                    $$ nest 2 (doc b)
  doc (M_read (a, b))    = parens $ text "M_read" $$ nest 2 (doc a)
                                                    $$ nest 2 (doc b)
  doc (M_print (a))      = parens $ text "M_print" $$ nest 2 (doc a)
  doc (M_return (a))     = parens $ text "M_return" $$ nest 2 (doc a)
  doc (M_block (a, b))   = parens $ text "M_block" $$ nest 2 (doc a)
                                                    $$ nest 2 (doc b)
  docPrec _ = doc

instance (Out a) => Out (M_type a) where
  doc M_int  = text "M_int"
  doc M_bool = text "M_bool"
  doc M_real = text "M_real"
  docPrec _ = doc

instance (Out a) => Out (M_expr a) where
  doc (M_ival a) = parens $ text "M_ival" <+> nest 2 (doc a) 
  doc (M_rval a) = parens $ text "M_rval" <+> nest 2 (doc a) 
  doc (M_bval a) = parens $ text "M_bval" <+> nest 2 (doc a) 
  doc (M_size (a,b)) = parens $ text "M_size" <+> (doc a) 
                                                    <+> (doc b)
  doc (M_id (a, b)) = parens $ text "M_id" <+> (doc a)
                                                    <+> (doc b)
  doc (M_app (a, b)) = parens $ text "M_app" <+> (doc a)
                                                    <+> (doc b)  

  docPrec _ = doc

---------------------------------------------
  
instance (Out a) => Out (M_operation a) where
  doc (M_fn a) =  text "M_fn" $$ nest 2 (doc a) 
  doc (M_add)  =  text "M_add"  
  doc (M_mul)  =  text "M_mul"  
  doc (M_sub)  =  text "M_sub"
  doc (M_div)  =  text "M_div"
  doc (M_neg)  =  text "M_neg"
  doc (M_lt)   =  text "M_lt" 
  doc (M_le)   =  text "M_le" 
  doc (M_gt)   =  text "M_gt" 
  doc (M_ge)   =  text "M_ge" 
  doc (M_eq)   =  text "M_eq" 
  doc (M_not)  =  text "M_not"
  doc (M_and)  =  text "M_and"
  doc (M_or)   =  text "M_or" 
  doc (M_float) = text "M_float"
  doc (M_floor) = text "M_floor"
  doc (M_ceil)  = text "M_ceil" 
  docPrec _ = doc  


main = do
    args <- getArgs
    conts <- readFile (args !! 0)
    let tok = tokens conts
    let ptree = pProg tok       
    putStrLn $ show ptree
    case ptree of
        Ok  tree -> do
            let ast = transProg tree
            putStrLn $ show ast
            pp ast
        Bad msg-> putStrLn msg