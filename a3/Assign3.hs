module Main where

-- Haskell module generated by the BNF converter

import Text.PrettyPrint 
import Text.PrettyPrint.GenericPretty
import LexAssignment
import ParAssignment
import ErrM
import System.Environment
import AbsAssignment
import SkelAssignment
import AST

instance (Out a) => Out (M_prog a) where
  doc (M_prog (a, b)) = parens $ text "M_prog" 
                           $$ nest 2 (brackets 
                                          (vcat (punctuate 
                                             (text ",") 
                                             (map (\a ->  nest 0 (doc a)) a))))
                           $$ nest 2 (brackets 
                                          (vcat (punctuate 
                                             (text ",") 
                                             (map (\a ->  nest 0 (doc a)) b))))
  docPrec _ = doc
  
instance (Out a) => Out (M_decl a) where
  doc (M_var (a, b, c)) = text "M_var" <+> (parens $ hsep (punctuate (text ",") [doc a, doc b, doc c] ))
  doc (M_fun (a, b, c, d, e)) = text "M_fun" $$ nest 2 (parens $ (doc a) 
                                                    <+> (doc b) 
                                                    <+> (doc c)
                                                    $$ nest 2 (docList d)
                                                    $$ nest 2 (docList e))
  docPrec _ = doc
  
instance (Out a) => Out (M_stmt a) where
  doc (M_ass (a, b, c))  = text "M_ass" $$ nest 2 (parens $ (vcat (punctuate (text ",") [doc a, doc b, doc c])))
  doc (M_while (a, b))   = text "M_while" $$ nest 2 (parens $ (doc a)
                                                    $$ nest 2 (doc b))
  doc (M_cond (a, b, c)) = text "M_cond" $$ nest 2 (parens $ (doc a)
                                                    $$  (doc b))
  doc (M_read (a, b))    = text "M_read" $$ nest 2 (parens $ hsep (punctuate (text ",") [doc a, doc b]))
  doc (M_print (a))      = text "M_print" $$ nest 2 (doc a)
  doc (M_return (a))	 = text "M_return" $$ nest 2 (doc a)
  doc (M_block (a, b))   = text "M_block" $$ nest 2 (doc a)
                                                    $$ nest 2 (doc b)
  docPrec _ = doc

instance (Out a) => Out (M_type a) where
  doc M_int  = text "M_int"
  doc M_bool = text "M_bool"
  doc M_real = text "M_real"
  docPrec _ = doc

instance (Out a) => Out (M_expr a) where
  doc (M_ival a) = text "M_ival" <+> doc a 
  doc (M_rval a) = text "M_rval" <+> doc a 
  doc (M_bval a) = text "M_bval" <+> doc a
  doc (M_size (a,b)) = text "M_size" <+> (parens $ hsep (punctuate (text ",") [doc a, doc b]))
  doc (M_id (a, b)) = text "M_id" <+> (parens $ hsep (punctuate (text ",") [doc a, doc b]))
  doc (M_app (a, b)) = text "M_app" <+> (parens $ hsep (punctuate (text ",") [doc a, doc b]))
  docPrec _ = doc

---------------------------------------------
  
instance (Out a) => Out (M_operation a) where
  doc (M_fn a) =  text "M_fn" $$ nest 2 (doc a) 
  doc (M_add)  =  text "M_add"  
  doc (M_mul)  =  text "M_mul"  
  doc (M_sub)  =  text "M_sub"
  doc (M_div)  =  text "M_div"
  doc (M_neg)  =  text "M_neg"
  doc (M_lt)   =  text "M_lt" 
  doc (M_le)   =  text "M_le" 
  doc (M_gt)   =  text "M_gt" 
  doc (M_ge)   =  text "M_ge" 
  doc (M_eq)   =  text "M_eq" 
  doc (M_not)  =  text "M_not"
  doc (M_and)  =  text "M_and"
  doc (M_or)   =  text "M_or" 
  doc (M_float) = text "M_float"
  doc (M_floor) = text "M_floor"
  doc (M_ceil)  = text "M_ceil" 
  docPrec _ = doc  


main = do
    args <- getArgs
    conts <- readFile (args !! 0)
    let tok = tokens conts
    let ptree = pProg tok       
    putStrLn $ show ptree
    case ptree of
        Ok  tree -> do
            let ast = transProg tree
            putStrLn $ show ast
            pp ast
        Bad msg-> putStrLn msg