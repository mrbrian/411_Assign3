module SkelAssignment where

-- Haskell module generated by the BNF converter

import LexAssignment
import ParAssignment
import ErrM
import System.Environment
import AbsAssignment

data M_prog = M_prog ([M_decl],[M_stmt])
data M_decl = M_var (String,[M_expr],M_type)
            | M_fun (String,[(String,Int,M_type)],M_type,[M_decl],[M_stmt])
data M_stmt = M_ass (String,[M_expr],M_expr)
            | M_while (M_expr,M_stmt)
            | M_cond (M_expr,M_stmt,M_stmt) 
            | M_read (String,[M_expr])
            | M_print M_expr
            | M_return M_expr
            | M_block ([M_decl],[M_stmt])
data M_type = M_int | M_bool | M_real 
data M_expr = M_ival Integer
            | M_rval Float
            | M_bval Bool
            | M_size (String,Int)
            | M_id (String,[M_expr])
            | M_app (M_operation,[M_expr])
data M_operation = M_fn String | M_add | M_mul | M_sub | M_div | M_neg
                 | M_lt | M_le | M_gt | M_ge | M_eq | M_not | M_and | M_or
                 | M_float | M_floor | M_ceil

				 
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> String
transIdent x = case x of
  Ident string -> string
  
transProg :: Prog -> M_prog
transProg x = case x of
  ProgBlock block -> M_prog ([], [])
  
transBlock :: Block -> ([M_decl],[M_stmt])
transBlock x = case x of
  Block1 declarations programbody -> (transDeclarations declarations, transProgram_body programbody)
  
transDeclarations :: Declarations -> [M_decl]
transDeclarations x = case x of
  Declarations1 declaration declarations -> [transDeclaration declaration]++(transDeclarations declarations)
  Declarations2 -> []
  
transDeclaration :: Declaration -> M_decl
transDeclaration x = case x of
  DeclarationVar_declaration vardeclaration -> transVar_declaration vardeclaration
  DeclarationFun_declaration fundeclaration -> transFun_declaration fundeclaration
  
transVar_declaration :: Var_declaration -> M_decl
transVar_declaration x = case x of
  Var_declaration1 ident arraydimensions type_ -> M_var (transIdent ident, transArray_dimensions arraydimensions, transType type_)
  
transType :: Type -> M_type
transType x = case x of
  Type_int -> M_int
  Type_real -> M_bool
  Type_bool -> M_real
  
transArray_dimensions :: Array_dimensions -> [M_expr]
transArray_dimensions x = case x of
  Array_dimensions1 expr arraydimensions -> [transExpr expr]++(transArray_dimensions arraydimensions)
  Array_dimensions2 -> []
  
transFun_declaration :: Fun_declaration -> M_decl
transFun_declaration x = do
  case x of
    Fun_declaration1 ident paramlist type_ funblock -> do
	  let (fbdecs, fbstmts) = transFun_block funblock
	  M_fun (transIdent ident, transParam_list paramlist, transType type_, fbdecs, fbstmts)
  
transFun_block :: Fun_block -> ([M_decl],[M_stmt])
transFun_block x = case x of
  Fun_block1 declarations funbody -> (transDeclarations declarations, transFun_body funbody)
  
transParam_list :: Param_list -> [(String,Int,M_type)]
transParam_list x = case x of
  Param_list1 parameters -> transParameters parameters
  
transParameters :: Parameters -> [(String,Int,M_type)]
transParameters x = case x of
  Parameters1 basicdeclaration moreparameters -> [transBasic_declaration]++(transMore_parameters moreparameters)
  Parameters2 -> []
  
transMore_parameters :: More_parameters -> Result
transMore_parameters x = case x of
  More_parameters1 basicdeclaration moreparameters -> failure x
  More_parameters2 -> failure x
  
transBasic_declaration :: Basic_declaration -> [String,[M_expr],Type]
transBasic_declaration x = case x of
  Basic_declaration1 ident basicarraydimensions type_ -> failure x
  
transBasic_array_dimensions :: Basic_array_dimensions -> [Int]
transBasic_array_dimensions x = case x of
  Basic_array_dimensions1 basicarraydimensions -> [1]++(transBasic_array_dimensions basicarraydimensions)
  Basic_array_dimensions2 -> []
  
transProgram_body :: Program_body -> [M_stmt]
transProgram_body x = case x of
  Program_body1 progstmts -> transProg_stmts progstmts
  
transFun_body :: Fun_body -> [M_stmt]
transFun_body x = case x of
  Fun_body1 progstmts expr -> failure x
  
transProg_stmts :: Prog_stmts -> [M_stmt]
transProg_stmts x = case x of
  Prog_stmts1 progstmt progstmts -> failure x
  Prog_stmts2 -> failure x
  
transProg_stmt :: Prog_stmt -> M_stmt
transProg_stmt x = case x of
  Prog_stmt1 expr progstmt1 progstmt2 -> M_cond (transExpr expr, transProg_stmt progstmt1, transProg_stmt progstmt2)
  Prog_stmt2 expr progstmt -> M_while (transExpr expr, transProg_stmt progstmt)
  Prog_stmt3 identifier -> failure x
  Prog_stmt4 identifier expr -> failure x
  Prog_stmt5 expr -> failure x
  Prog_stmt6 block -> failure x
  
transIdentifier :: Identifier -> Result
transIdentifier x = case x of
  Identifier1 ident arraydimensions -> failure x
  
transExpr :: Expr -> M_expr
transExpr x = case x of
  Expr1 expr bintterm -> failure x
  ExprBint_term bintterm -> failure x
  
transBint_term :: Bint_term -> Result
transBint_term x = case x of
  Bint_term1 bintterm bintfactor -> failure x
  Bint_termBint_factor bintfactor -> failure x
  
transBint_factor :: Bint_factor -> Result
transBint_factor x = case x of
  Bint_factor1 bintfactor -> failure x
  Bint_factor2 intexpr1 compareop intexpr2 -> failure x
  Bint_factorInt_expr intexpr -> failure x
  
transCompare_op :: Compare_op -> Result
transCompare_op x = case x of
  Compare_op1 -> failure x
  Compare_op2 -> failure x
  Compare_op3 -> failure x
  Compare_op4 -> failure x
  Compare_op5 -> failure x
  
transInt_expr :: Int_expr -> Result
transInt_expr x = case x of
  Int_expr1 intexpr addop intterm -> failure x
  Int_exprInt_term intterm -> failure x
  
transAddop :: Addop -> Expr
transAddop x = case x of
  Addop1 -> failure x
  Addop2 -> failure x
  
transInt_term :: Int_term -> Result
transInt_term x = case x of
  Int_term1 intterm mulop intfactor -> failure x
  Int_termInt_factor intfactor -> failure x
  
transMulop :: Mulop -> M_operation
transMulop x = case x of
  Mulop1 -> M_mul
  Mulop2 -> M_div 
  
transInt_factor :: Int_factor -> M_expr
transInt_factor x = case x of
  Int_factor1 expr -> transExpr expr
  -- size   ... returns the size of the array somehow??
  Int_factor2 ident basicarraydimensions -> M_size(transIdent ident, transBasic_array_dimensions basicarraydimensions)
  -- float
  Int_factor3 expr -> M_rval 
  -- floor
  Int_factor4 expr -> M_floor 
  Int_factor5 expr -> M_ceil
  Int_factor6 ident modifierlist -> transIdent ident transModifier_list modifierlist
  Int_factorBval bval -> transBval bval
  Int_factor7 intfactor -> M_app(M_mul, [M_ival -1, transInt_factor intfactor]
  
transModifier_list :: Modifier_list -> [M_expr]
transModifier_list x = case x of
  Modifier_list1 arguments -> transArguments arguments
  Modifier_listArray_dimensions arraydimensions -> transArray_dimensions arraydimensions
  
transArguments :: Arguments -> [M_expr]
transArguments x = case x of
  Arguments1 expr morearguments -> [expr]++(transArguments morearguments)
  Arguments2 -> []
  
transMore_arguments :: More_arguments -> [M_expr]
transMore_arguments x = case x of
  More_arguments1 expr morearguments -> [transExpr expr]++(transMore_arguments morearguments)
  More_arguments2 -> []
  
transBval :: Bval -> M_expr
transBval x = case x of
  Bval_true -> M_bval True
  Bval_false -> M_bval False
